ğŸ“„ Fiche explicative complÃ¨te du code v0.1 (sans arguments)

ğŸ” Vue d'ensemble
Ce shell basique lit des commandes sans arguments et les exÃ©cute dans un processus fils.
Exemple : /bin/ls uniquement (pas /bin/ls -l)

ğŸ“š Includes et dÃ©finitions
c#include <stdio.h>       // printf, fprintf, perror, getline
#include <stdlib.h>      // malloc, free, exit
#include <string.h>      // strlen
#include <unistd.h>      // fork, execve, write, isatty, STDIN_FILENO, STDOUT_FILENO
#include <sys/types.h>   // pid_t, size_t, ssize_t
#include <sys/wait.h>    // wait

#define BUFFER_SIZE 1024 // DÃ©fini mais non utilisÃ© dans ce code
Explication des includes
IncludeFonctions utilisÃ©esstdio.hgetline(), fprintf(), perror()stdlib.hexit(), free()string.hstrlen()unistd.hfork(), execve(), write(), isatty()sys/types.hTypes pid_t, size_t, ssize_tsys/wait.hwait()
Note sur BUFFER_SIZE
c#define BUFFER_SIZE 1024

DÃ©fini mais non utilisÃ© dans ce code
Peut Ãªtre supprimÃ© ou gardÃ© pour Ã©volutions futures
getline() gÃ¨re l'allocation automatiquement


ğŸ“‹ Variables principales
cint main(void)
{
	char *line = NULL;           // Pointeur vers ligne lue
	size_t len = 0;              // Taille buffer allouÃ© par getline
	ssize_t nread;               // Nombre octets lus (-1 si EOF)
	pid_t pid;                   // ID processus (0=fils, >0=parent, -1=erreur)
	int status;                  // Statut sortie processus fils
	char *argv[2];               // Tableau arguments (commande + NULL)
	extern char **environ;       // Variables environnement systÃ¨me
Tableau dÃ©taillÃ© des variables
VariableTypeInitialisationRÃ´lelinechar *NULLPointe vers ligne allouÃ©e par getlinelensize_t0Taille buffer (gÃ©rÃ© par getline)nreadssize_t-Octets lus (incluant \n)pidpid_t-RÃ©sultat de fork()statusint-Code sortie filsargvchar *[2]-[0]=commande, [1]=NULLenvironchar **externTableau variables env
Pourquoi argv[2] ?
cchar *argv[2];
Taille fixe car pas d'arguments :
cargv[0] = "/bin/ls"    // La commande
argv[1] = NULL         // Fin du tableau (obligatoire)
```

**SchÃ©ma mÃ©moire :**
```
argv :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ argv[0] â”‚ NULL â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
    â†“
 "/bin/ls"

ğŸ”„ Structure de la boucle principale
cwhile (1)
{
    // 1. Afficher prompt
    // 2. Lire commande
    // 3. VÃ©rifier EOF
    // 4. Nettoyer ligne
    // 5. Ignorer lignes vides
    // 6. Fork + Execute
}

1ï¸âƒ£ Affichage du prompt
c/* Display prompt */
if (isatty(STDIN_FILENO))
    write(STDOUT_FILENO, "#cisfun$ ", 9);
Analyse dÃ©taillÃ©e
isatty(STDIN_FILENO) - Teste si c'est un terminal
CasRetourComportementTerminal (user tape)1 (vrai)Affiche promptPipe (echo "..." | ./shell)0 (faux)Pas de promptRedirection (./shell < file)0 (faux)Pas de prompt
Constantes systÃ¨me :
cSTDIN_FILENO  = 0  // EntrÃ©e standard
STDOUT_FILENO = 1  // Sortie standard
STDERR_FILENO = 2  // Sortie erreur
write(STDOUT_FILENO, "#cisfun$ ", 9) - Ã‰crit sur stdout
cwrite(fd, buffer, count)
//    â”‚   â”‚       â””â”€ Nombre d'octets Ã  Ã©crire
//    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pointeur vers donnÃ©es
//    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ File descriptor
Pourquoi write() et pas printf() ?

Plus bas niveau (appel systÃ¨me direct)
Plus rapide
Pas de buffering
Fonctionne mÃªme si stdout redirigÃ©

Pourquoi 9 ?
c"#cisfun$ "
 123456789  â†’ 9 caractÃ¨res
Exemples d'utilisation
Mode interactif :
bash$ ./shell
#cisfun$ /bin/pwd          â† Prompt affichÃ©
/home/user
#cisfun$ /bin/ls           â† Prompt affichÃ©
file1 file2
Mode non-interactif (pipe) :
bash$ echo "/bin/pwd" | ./shell
/home/user                 â† Pas de prompt (propre !)
Mode non-interactif (fichier) :
bash$ cat commands.txt
/bin/pwd
/bin/ls

$ ./shell < commands.txt
/home/user                 â† Pas de prompt
file1 file2

2ï¸âƒ£ Lecture de la commande
c/* Read command from user */
nread = getline(&line, &len, stdin);
Fonctionnement de getline()
cssize_t getline(char **lineptr, size_t *n, FILE *stream);
//              â”‚              â”‚            â””â”€ D'oÃ¹ lire (stdin)
//              â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Taille buffer (in/out)
//              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pointeur vers buffer (in/out)
Exemple pas Ã  pas
Ã‰tat initial :
cchar *line = NULL;
size_t len = 0;
Premier appel - User tape : "/bin/ls"
cnread = getline(&line, &len, stdin);

// AprÃ¨s :
line â†’ "/bin/ls\n\0"     // malloc() fait automatiquement
len = 120                // Taille allouÃ©e (peut varier)
nread = 8                // Octets lus (7 chars + '\n')
DeuxiÃ¨me appel - User tape : "/bin/pwd"
cnread = getline(&line, &len, stdin);

// AprÃ¨s :
line â†’ "/bin/pwd\n\0"    // RÃ©utilise buffer existant
len = 120                // InchangÃ© (buffer assez grand)
nread = 9                // Octets lus
TroisiÃ¨me appel - User tape ligne TRÃˆS longue (>120 chars)
cnread = getline(&line, &len, stdin);

// AprÃ¨s :
line â†’ "longue ligne...\n\0"  // realloc() automatique !
len = 240                     // Agrandi automatiquement
nread = 150                   // Octets lus
Gestion mÃ©moire
c// getline fait automatiquement :
if (line == NULL)
    line = malloc(initial_size);
else if (input_too_long)
    line = realloc(line, bigger_size);
C'est pour Ã§a qu'on doit faire free(line) Ã  la fin !
Valeurs de retour
ValeurSignification> 0Nombre d'octets lus (succÃ¨s)-1EOF ou erreur

3ï¸âƒ£ Gestion de l'EOF (End Of File)
c/* Handle EOF (Ctrl+D) */
if (nread == -1)
{
    if (isatty(STDIN_FILENO))
        write(STDOUT_FILENO, "\n", 1);
    break;
}
Quand nread == -1 ?
Cas 1 : Utilisateur tape Ctrl+D
bash$ ./shell
#cisfun$ /bin/ls
file1 file2
#cisfun$ ^D              â† Ctrl+D
                         â† write("\n") pour ligne propre
$                        â† Retour au shell parent
Cas 2 : Fin de fichier en mode non-interactif
bash$ echo "/bin/pwd" | ./shell
/home/user
                         â† EOF automatique, shell termine
$
Cas 3 : Erreur de lecture (rare)
bash# Erreur matÃ©rielle ou fermeture stdin
nread = -1
Pourquoi write("\n") ?
Sans le \n :
bash$ ./shell
#cisfun$ ^D$             â† CollÃ© au prompt suivant
Avec le \n :
bash$ ./shell
#cisfun$ ^D
$                        â† Propre !
Mais seulement en mode interactif :
cif (isatty(STDIN_FILENO))  // Seulement si terminal
    write(STDOUT_FILENO, "\n", 1);
Le break
cbreak;  // Sort de while(1), termine le programme
```

**Flux :**
```
while (1) {
    if (nread == -1) {
        break;  â”€â”€â†’ Sort de la boucle
    }
}
free(line);  â†â”€â”€ Arrive ici
return (0);  â†â”€â”€ Puis termine

4ï¸âƒ£ Nettoyage de la ligne (suppression du '\n')
c/* Remove newline character */
if (line[nread - 1] == '\n')
    line[nread - 1] = '\0';
Pourquoi faire Ã§a ?
Ce que getline() retourne :
c// User tape : /bin/ls [EntrÃ©e]
line = "/bin/ls\n\0"
nread = 8
Ce qu'on veut :
cline = "/bin/ls\0"
Analyse index par index
c// line = "/bin/ls\n\0"
// Index:  0123456 7 8

nread = 8

line[nread - 1]  = line[7]  = '\n'  â† On vÃ©rifie
line[7] = '\0'                      â† On remplace

// RÃ©sultat: line = "/bin/ls\0\0"
Pourquoi vÃ©rifier == '\n' ?
Cas normal :
cUser tape: /bin/ls [EntrÃ©e]
line = "/bin/ls\n\0"
line[7] == '\n'  â†’ TRUE â†’ Remplace par '\0'
Cas spÃ©cial - derniÃ¨re ligne sans '\n' :
bash$ cat file.txt
/bin/ls
/bin/pwd            â† Pas de retour ligne Ã  la fin

$ ./shell < file.txt
c// DerniÃ¨re ligne
line = "/bin/pwd\0"
line[8] == '\0'  â†’ FALSE â†’ Ne fait rien (correct!)
```

### SchÃ©ma avant/aprÃ¨s

**Avant :**
```
line:
â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚/â”‚bâ”‚iâ”‚nâ”‚/â”‚lâ”‚sâ”‚\nâ”‚\0â”‚
â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”€â”´â”€â”€â”˜
 0 1 2 3 4 5 6  7  8
               â†‘
            nread-1
```

**AprÃ¨s :**
```
line:
â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚/â”‚bâ”‚iâ”‚nâ”‚/â”‚lâ”‚sâ”‚\0â”‚\0â”‚
â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”€â”´â”€â”€â”˜
               â†‘
           RemplacÃ©

5ï¸âƒ£ Ignorer les lignes vides
c/* Skip empty lines */
if (strlen(line) == 0)
    continue;
Quand est-ce utile ?
Cas 1 : Utilisateur appuie juste sur EntrÃ©e
bash#cisfun$ 
#cisfun$              â† Ligne vide, continue boucle
#cisfun$ /bin/ls      â† Commande valide
Cas 2 : Fichier avec lignes vides
bash$ cat commands.txt
/bin/pwd

/bin/ls

$ ./shell < commands.txt
/home/user            â† Ligne vide ignorÃ©e
file1 file2           â† Ligne vide ignorÃ©e
Fonctionnement de strlen()
csize_t strlen(const char *s);
Compte caractÃ¨res jusqu'Ã  '\0' :
cstrlen("")         â†’ 0
strlen("\0")       â†’ 0
strlen("/bin/ls")  â†’ 7
Flux avec continue
cwhile (1) {
    // ...
    if (strlen(line) == 0)
        continue;  â”€â”€â†’ Retour dÃ©but de boucle (affiche prompt)
    
    // Code exÃ©cution (ignorÃ© si ligne vide)
}

6ï¸âƒ£ Fork - CrÃ©ation du processus fils
c/* Fork process to execute command */
pid = fork();
```

### Qu'est-ce que fork() ?

**`fork()` clone le processus actuel**
```
AVANT fork() :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shell           â”‚
â”‚ PID: 1234       â”‚
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS fork() :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parent (shell)  â”‚         â”‚ Fils (clone)    â”‚
â”‚ PID: 1234       â”‚         â”‚ PID: 5678       â”‚
â”‚ pid = 5678      â”‚         â”‚ pid = 0         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Valeurs de retour de fork()
DansValeur de pidSignificationParent> 0PID du fils (ex: 5678)Fils0Je suis le filsErreur-1Fork a Ã©chouÃ©
Exemple concret
cprintf("Avant fork\n");
pid = fork();

if (pid == 0)
    printf("Je suis le FILS, mon PID=%d\n", getpid());
else if (pid > 0)
    printf("Je suis le PARENT, fils PID=%d\n", pid);
```

**Sortie :**
```
Avant fork
Je suis le PARENT, fils PID=5678
Je suis le FILS, mon PID=5678
Les deux processus s'exÃ©cutent en parallÃ¨le !

7ï¸âƒ£ Gestion erreur fork
cif (pid == -1)
{
    perror("./shell");
    continue;
}
Quand fork() Ã©choue ?
Raisons courantes :

Plus de mÃ©moire disponible
Limite processus atteinte
ProblÃ¨me systÃ¨me

Comportement avec perror()
cperror("./shell");
```

**Affiche :**
```
./shell: Cannot allocate memory
```

ou
```
./shell: Resource temporarily unavailable
Pourquoi continue ?
ccontinue;  // Retour dÃ©but boucle, redemande commande
Flux :
bash#cisfun$ /bin/ls
./shell: Cannot allocate memory
#cisfun$              â† Continue, redemande
Sans continue :
c// Tomberait dans if (pid == 0) avec pid = -1 !
// Comportement indÃ©fini !

8ï¸âƒ£ Processus fils - ExÃ©cution
cif (pid == 0)
{
    /* Child process */
    argv[0] = line;
    argv[1] = NULL;

    /* Execute command */
    if (execve(line, argv, environ) == -1)
    {
        fprintf(stderr, "./shell: No such file or directory\n");
        exit(127);
    }
}
Analyse ligne par ligne
Test si on est le fils :
cif (pid == 0)  // fork() a retournÃ© 0 â†’ on est le FILS
Construction de argv :
cargv[0] = line;    // Pointe vers "/bin/ls" (par exemple)
argv[1] = NULL;    // âš ï¸ OBLIGATOIRE pour execve()
```

**SchÃ©ma mÃ©moire :**
```
line â†’ "/bin/ls\0"
       â†‘
argv:  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ argv[0]  â”‚ NULL â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
Appel Ã  execve :
cif (execve(line, argv, environ) == -1)
//         â”‚     â”‚      â””â”€ Variables environnement
//         â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€ Tableau arguments
//         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Chemin programme
```

### Que fait execve() ?

**`execve()` remplace complÃ¨tement le processus**
```
AVANT execve("/bin/ls") :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Fils             â”‚
â”‚ Code: shell      â”‚
â”‚ MÃ©moire: shell   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS execve("/bin/ls") :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Fils (mÃªme PID)  â”‚
â”‚ Code: /bin/ls    â”‚ â† REMPLACÃ‰ !
â”‚ MÃ©moire: ls      â”‚ â† REMPLACÃ‰ !
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Si succÃ¨s :

Le code du shell est effacÃ©
Le code de /bin/ls le remplace
Le processus ne revient JAMAIS ici
/bin/ls s'exÃ©cute et termine

Si Ã©chec (retourne -1) :

Programme introuvable
Pas de permissions
Erreur fichier

Gestion d'erreur
cif (execve(line, argv, environ) == -1)
On arrive ici SEULEMENT si execve() Ã©choue
cfprintf(stderr, "./shell: No such file or directory\n");
Affiche sur stderr (sortie erreur) :
bash#cisfun$ /bin/commande_fausse
./shell: No such file or directory
cexit(127);
Code 127 = convention UNIX pour "commande introuvable"
Pourquoi exit() est CRUCIAL ?
Sans exit() :
cif (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        // PAS D'EXIT !
    }
}
// Le fils continue et retourne Ã  la boucle while
// â†’ 2 shells en parallÃ¨le qui affichent des prompts !
Avec exit() :
cif (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        exit(127);  // âœ… Fils termine proprement
    }
}
```

### Flux d'exÃ©cution complet
```
FILS:
1. pid = 0 (je suis le fils)
2. argv[0] = "/bin/ls"
3. argv[1] = NULL
4. execve("/bin/ls", argv, environ)
   
   CAS A - SuccÃ¨s:
   â†’ Processus remplacÃ© par /bin/ls
   â†’ ls s'exÃ©cute
   â†’ ls termine (exit automatique)
   
   CAS B - Ã‰chec:
   â†’ execve() retourne -1
   â†’ fprintf("No such file...")
   â†’ exit(127)
   â†’ Fils termine

9ï¸âƒ£ Processus parent - Attente
celse
{
    /* Parent process - wait for child */
    wait(&status);
}
Que fait le parent ?
celse  // pid > 0, on est le PARENT
wait(&status) - Attend la fin du fils
cpid_t wait(int *status);
//          â””â”€ Pointeur oÃ¹ stocker le statut de sortie
```

### Comportement de wait()

**Le parent se BLOQUE jusqu'Ã  ce que le fils termine**
```
Parent                          Fils
  â”‚                              â”‚
  â”œâ”€ fork() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                              â”‚
  â”œâ”€ wait() â”€â”€â”€â”€â†’ BLOQUÃ‰         â”œâ”€ execve("/bin/ls")
  â”‚              ATTEND          â”œâ”€ ls s'exÃ©cute...
  â”‚              ...             â”œâ”€ ls affiche rÃ©sultats
  â”‚              ...             â””â”€ ls termine (exit)
  â”‚                              
  â”œâ”€ REPREND â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â””â”€ Continue boucle (affiche prompt)
Exemple temporel
bash$ ./shell
#cisfun$ /bin/sleep 5
                              â† Wait 5 secondes...
                              â† Parent BLOQUÃ‰
#cisfun$                      â† Prompt aprÃ¨s 5 sec
Variable status
cint status;
wait(&status);
Contient le code de sortie du fils :
c// Si fils fait : exit(0)
// status contiendra : 0

// Si fils fait : exit(127)
// status contiendra : 127
Dans notre code, on ne l'utilise pas, mais on pourrait :
cwait(&status);

if (WIFEXITED(status))
{
    int exit_code = WEXITSTATUS(status);
    if (exit_code == 127)
        printf("Commande introuvable\n");
}
Sans wait() - ProblÃ¨me !
c// SANS WAIT (MAUVAIS)
if (pid == 0) {
    execve(...);
} else {
    // Pas de wait !
    // Continue immÃ©diatement !
}
RÃ©sultat :
bash#cisfun$ /bin/sleep 5
#cisfun$                      â† Prompt IMMÃ‰DIAT !
                              â† sleep continue en arriÃ¨re-plan
Processus "zombie" :

Fils termine mais parent ne rÃ©cupÃ¨re pas son status
Reste en mÃ©moire


ğŸ”Ÿ Fin du programme
c/* Free allocated memory */
free(line);

return (0);
Pourquoi free(line) ?
getline() alloue automatiquement :
c// Premier appel
char *line = NULL;
getline(&line, &len, stdin);
// â†’ malloc() fait automatiquement
// â†’ line pointe vers mÃ©moire allouÃ©e
On doit libÃ©rer :
cfree(line);  // LibÃ¨re la mÃ©moire
Sans free() :
c// Fuite mÃ©moire
// La mÃ©moire reste allouÃ©e mÃªme aprÃ¨s fin du programme
// (OK pour un programme court, mais mauvaise pratique)
return 0
creturn (0);  // Code de sortie 0 = succÃ¨s
Conventions :

0 = succÃ¨s
!= 0 = erreur

Utilisable en bash :
bash$ ./shell
#cisfun$ ^D

$ echo $?
0                  â† Code de sortie du shell
```

---

## ğŸ¯ Flux complet d'exÃ©cution
```
1. Initialisation variables
   â”‚
2. â”Œâ†’ while (1) {
   â”‚    â”‚
3. â”‚  â”œâ”€ Affiche "#cisfun$ " (si terminal)
   â”‚  â”‚
4. â”‚  â”œâ”€ getline() â†’ lit "/bin/ls"
   â”‚  â”‚
5. â”‚  â”œâ”€ Si EOF â†’ break (sort boucle)
   â”‚  â”‚
6. â”‚  â”œâ”€ EnlÃ¨ve '\n' â†’ "/bin/ls\0"
   â”‚  â”‚
7. â”‚  â”œâ”€ Si ligne vide â†’ continue (retour Ã©tape 2)
   â”‚  â”‚
8. â”‚  â”œâ”€ pid = fork()
   â”‚  â”‚     â”‚
   â”‚  â”‚     â”œâ”€ PARENT (pid > 0)     FILS (pid = 0)
   â”‚  â”‚     â”‚   â”‚                    â”‚
   â”‚  â”‚     â”‚   â””â”€ wait() BLOQUÃ‰     â”œâ”€ argv[0] = "/bin/ls"
   â”‚  â”‚     â”‚                        â”œâ”€ argv[1] = NULL
   â”‚  â”‚     â”‚                        â”œâ”€ execve("/bin/ls", argv, environ)
   â”‚  â”‚     â”‚                        â”‚   â†’ Devient ls
   â”‚  â”‚     â”‚                        â”‚   â†’ ExÃ©cute
   â”‚  â”‚     â”‚                        â””â”€ Termine (exit)
   â”‚  â”‚     â”‚                        
   â”‚  â”‚     â””â”€ REPREND â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚  â”‚
9. â”‚  â””â”€ Retour Ã©tape 2 (nouveau prompt)
   â”‚  }
   â”‚
10. â””â”€ free(line)
   â”‚
11. â””â”€ return 0

ğŸ“Š Tableau rÃ©capitulatif des fonctions
FonctionParamÃ¨tresRetourRÃ´leisatty()int fd1 ou 0VÃ©rifie si terminalwrite()int fd, void *buf, size_t nOctets Ã©critsÃ‰crit sur FDgetline()char **line, size_t *n, FILE *fOctets lusLit ligne complÃ¨testrlen()const char *sNombre charsLongueur chaÃ®nefork()-pid_tClone processusexecve()char *path, char **argv, char **env-1 si erreurRemplace processuswait()int *statusPID filsAttend filsfprintf()FILE *f, char *fmt, ...Octets Ã©critsÃ‰crit formatÃ©perror()const char *svoidAffiche erreur systÃ¨meexit()int code-Termine processusfree()void *ptrvoidLibÃ¨re mÃ©moire

ğŸ” Exemples de cas d'usage
Cas 1 : Commande valide
bashInput: /bin/pwd
```
```
1. Affiche "#cisfun$ "
2. getline() â†’ "/bin/pwd\n"
3. EnlÃ¨ve \n â†’ "/bin/pwd\0"
4. fork()
5. FILS: execve("/bin/pwd", ["/bin/pwd", NULL], environ)
   â†’ Affiche: /mnt/d/holbertonschool-simple_shell
   â†’ Termine
6. PARENT: wait() attend fils
7. Continue boucle
Cas 2 : Commande inexistante
bashInput: /bin/fausse
```
```
1. Affiche "#cisfun$ "
2. getline() â†’ "/bin/fausse\n"
3. EnlÃ¨ve \n â†’ "/bin/fausse\0"
4. fork()
5. FILS: execve("/bin/fausse", [...], environ)
   â†’ Retourne -1 (pas trouvÃ©)
   â†’ fprintf("No such file...")
   â†’ exit(127)
6. PARENT: wait() rÃ©cupÃ¨re status=127
7. Continue boucle
Cas 3 : Ligne vide
bashInput: [EntrÃ©e]
```
```
1. Affiche "#cisfun$ "
2. getline() â†’ "\n"
3. EnlÃ¨ve \n â†’ "\0"
4. strlen() == 0 â†’ continue
5. Retour Ã©tape 1 (nouveau prompt)
Cas 4 : EOF (Ctrl+D)
bashInput: ^D
```
```
1. Affiche "#cisfun$ "
2. getline() â†’ retourne -1
3. Affiche "\n" (si terminal)
4. break (sort boucle)
5. free(line)
6. return 0
Cas 5 : Mode non-interactif
bash$ echo "/bin/pwd" | ./shell
```
```
1. isatty() â†’ 0 (pas de prompt)
2. getline() â†’ "/bin/pwd\n"
3. EnlÃ¨ve \n â†’ "/bin/pwd\0"
4. fork() + execve()
5. Affiche: /home/user
6. getline() â†’ -1 (EOF)
7. break

ğŸ› Erreurs courantes
âŒ Erreur 1 : Oublier argv[1] = NULL
c// MAUVAIS
argv[0] = line;
// Pas de argv[1] = NULL !
execve(line, argv, environ);
ConsÃ©quence : Comportement indÃ©fini
Correction :
cargv[0] = line;
argv[1] = NULL;  // âœ…
âŒ Erreur 2 : Fils ne termine pas
c// MAUVAIS
if (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        // Pas d'exit !
    }
    // Continue et affiche un prompt !
}
Correction :
cif (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        exit(127);  // âœ…
    }
}
âŒ Erreur 3 : Oublier free()
c// MAUVAIS
int main(void)
{
    char *line = NULL;
    // ...
    return (0);  // Fuite mÃ©moire !
}
Correction :
cfree(line);  // âœ…
return (0);
âŒ Erreur 4 : Pas de wait()
c// MAUVAIS
if (pid == 0) {
    execve(...);
} else {
    // Pas de wait !
    // Continue immÃ©diatement
}
Correction :
celse {
    wait(&status);  // âœ…
}

ğŸ’¡ Limitations de cette version
LimitationExempleVersion futureâŒ Pas d'argumentsls -l ne marche pasv0.2âŒ Pas de PATHls ne marche pas (besoin /bin/ls)v0.3âŒ Pas de built-insexit, cd ne marchent pasv0.4+âŒ Pas de pipesls | grep ne marche pasv0.5+âŒ Pas de redirectionsls > file ne marche pasv0.6+

âœ… Ce que fait bien ce shell
âœ… Affiche prompt en mode interactif uniquement
âœ… Lit commandes de n'importe quelle longueur
âœ… GÃ¨re EOF proprement (Ctrl+D)
âœ… Ignore lignes vides
âœ… ExÃ©cute commandes avec chemin complet
âœ… Affiche erreurs appropriÃ©es
âœ… Pas de fuite mÃ©moire
âœ… Gestion processus correcte (fork/wait)

ğŸ“ Concepts clÃ©s

getline() alloue automatiquement, on doit free()
fork() clone le processus en 2 : parent et fils
execve() remplace le processus (ne retourne jamais si succÃ¨s)
wait() bloque le parent jusqu'Ã  fin du fils
argv doit TOUJOURS terminer par NULL
Le fils doit exit() aprÃ¨s Ã©chec de execve()
isatty() permet mode interactif/non-interactif