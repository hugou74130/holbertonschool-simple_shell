üìÑ Fiche explicative compl√®te du code v0.2

üîç Vue d'ensemble
Ce shell lit des commandes avec arguments, les parse, et les ex√©cute dans un processus fils.
Exemple : /bin/ls -l -a devient argv[0]="/bin/ls", argv[1]="-l", argv[2]="-a"

üìö Includes et d√©finitions
c#include <stdio.h>       // printf, fprintf, perror, getline
#include <stdlib.h>      // malloc, free, exit
#include <string.h>      // strlen, strtok
#include <unistd.h>      // fork, execve, write, isatty
#include <sys/types.h>   // pid_t, size_t, ssize_t
#include <sys/wait.h>    // wait

#define MAX_ARGS 64      // Maximum 63 arguments + NULL
Pourquoi MAX_ARGS ?

Limite le nombre d'arguments possibles
√âvite les d√©bordements de buffer
64 = 63 arguments + 1 NULL final


üìã Variables principales
cint main(void)
{
    char *line = NULL;           // Ligne lue par getline
    size_t len = 0;              // Taille du buffer allou√©
    ssize_t nread;               // Nombre d'octets lus
    pid_t pid;                   // ID du processus (fork)
    int status;                  // Statut de sortie du fils
    char *argv[MAX_ARGS];        // Tableau d'arguments
    char *token;                 // Token temporaire (strtok)
    int i;                       // Compteur de boucle
    extern char **environ;       // Variables d'environnement
VariableTypeR√¥lelinechar *Pointe vers la ligne luelensize_tTaille du buffer allou√©nreadssize_tOctets lus (-1 si EOF)pidpid_tID processus (0=fils, >0=parent)statusintCode de sortie du filsargvchar *[]Tableau de pointeurs vers argumentstokenchar *Pointeur temporaireiintIndex pour remplir argvenvironchar **Environnement syst√®me

üîÑ Boucle principale
cwhile (1)
{
    // 1. Afficher le prompt
    // 2. Lire la commande
    // 3. Parser les arguments
    // 4. Fork + Execute
}

1Ô∏è‚É£ Affichage du prompt
cif (isatty(STDIN_FILENO))
    write(STDOUT_FILENO, "#cisfun$ ", 9);
Explication :

isatty(STDIN_FILENO) ‚Üí V√©rifie si stdin est un terminal

Retourne 1 = mode interactif (utilisateur tape)
Retourne 0 = mode non-interactif (pipe/fichier)


write(STDOUT_FILENO, "#cisfun$ ", 9)

√âcrit 9 caract√®res sur stdout
Utilise write() au lieu de printf() (plus bas niveau)



Pourquoi cette v√©rification ?
bash# Mode interactif
./shell
#cisfun$ ls          ‚Üê Prompt affich√©

# Mode non-interactif
echo "ls" | ./shell
file1 file2          ‚Üê Pas de prompt (propre)

2Ô∏è‚É£ Lecture de la commande
cnread = getline(&line, &len, stdin);
Comment √ßa marche :
c// Avant premier appel
line = NULL
len = 0

// Apr√®s getline (user tape: "/bin/ls -l")
line ‚Üí "/bin/ls -l\n\0"  (malloc automatique)
len = 120                 (taille buffer allou√©)
nread = 11               (octets lus incluant \n)
Allocation automatique :

getline() fait le malloc() automatiquement
Redimensionne si ligne trop longue
On doit faire free(line) √† la fin


3Ô∏è‚É£ Gestion EOF
cif (nread == -1)
{
    if (isatty(STDIN_FILENO))
        write(STDOUT_FILENO, "\n", 1);
    break;
}
Quand nread == -1 ?

Utilisateur tape Ctrl+D (EOF)
Fin de fichier en mode non-interactif
Erreur de lecture

Pourquoi \n ?
bash$ ./shell
#cisfun$ ^D
               ‚Üê Sans \n, le prompt suivant serait coll√©
$              ‚Üê Propre avec \n

4Ô∏è‚É£ Nettoyage de la ligne
cif (line[nread - 1] == '\n')
    line[nread - 1] = '\0';
Avant :
cline = "/bin/ls\n\0"
nread = 8
Apr√®s :
cline = "/bin/ls\0\0"  // \n remplac√© par \0
Pourquoi ?

execve() ne veut pas de \n
strtok() fonctionnerait mais propret√© du code


5Ô∏è‚É£ Ignorer lignes vides
cif (strlen(line) == 0)
    continue;
Cas d'usage :
bash#cisfun$ 
#cisfun$           ‚Üê Utilisateur appuie juste sur Entr√©e
#cisfun$ /bin/ls   ‚Üê Commande valide

6Ô∏è‚É£ Parsing (le c≈ìur du changement v0.2)
ci = 0;
token = strtok(line, " \t");
while (token != NULL && i < MAX_ARGS - 1)
{
    argv[i] = token;
    i++;
    token = strtok(NULL, " \t");
}
argv[i] = NULL;
√âtape par √©tape
Ligne originale :
cline = "/bin/ls -l -a\0"
Premier appel strtok :
ctoken = strtok(line, " \t");
// line devient : "/bin/ls\0-l -a\0"
// token pointe vers : "/bin/ls"
Boucle - It√©ration 1 :
cargv[0] = token;     // argv[0] = "/bin/ls"
i++;                 // i = 1
token = strtok(NULL, " \t");
// line devient : "/bin/ls\0-l\0-a\0"
// token pointe vers : "-l"
Boucle - It√©ration 2 :
cargv[1] = token;     // argv[1] = "-l"
i++;                 // i = 2
token = strtok(NULL, " \t");
// token pointe vers : "-a"
Boucle - It√©ration 3 :
cargv[2] = token;     // argv[2] = "-a"
i++;                 // i = 3
token = strtok(NULL, " \t");
// token = NULL (fin)
Sortie de boucle :
cargv[i] = NULL;      // argv[3] = NULL
R√©sultat final
cargv[0] = "/bin/ls"
argv[1] = "-l"
argv[2] = "-a"
argv[3] = NULL       // ‚ö†Ô∏è OBLIGATOIRE pour execve()
```

### Sch√©ma m√©moire
```
line en m√©moire apr√®s strtok:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê
‚îÇ/bin/ls ‚îÇ\0‚îÇ-l ‚îÇ\0‚îÇ-a ‚îÇ\0‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò
   ‚Üë         ‚Üë      ‚Üë     
argv[0]   argv[1] argv[2]  argv[3]=NULL
Pourquoi " \t" ?
cstrtok(line, " \t");
//            ‚îÇ  ‚îî‚îÄ‚îÄ Tabulation
//            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Espace
G√®re les deux d√©limiteurs :
bash"/bin/ls -l"       # Espaces
"/bin/ls	-l"    # Tabulations
"/bin/ls  -l"      # Espaces multiples (ignor√©s auto)
Pourquoi i < MAX_ARGS - 1 ?
cwhile (token != NULL && i < MAX_ARGS - 1)
//                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//                       Garde une place pour NULL
Exemple avec MAX_ARGS = 4 :
ci=0 ‚Üí argv[0] = arg1
i=1 ‚Üí argv[1] = arg2
i=2 ‚Üí argv[2] = arg3
i=3 ‚Üí STOP (garde argv[3] pour NULL)
argv[3] = NULL

7Ô∏è‚É£ Fork (cr√©ation processus fils)
cpid = fork();
```

**Ce qui se passe :**
```
AVANT fork():
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Shell        ‚îÇ
‚îÇ PID: 1234    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

APR√àS fork():
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Parent       ‚îÇ         ‚îÇ Fils         ‚îÇ
‚îÇ PID: 1234    ‚îÇ         ‚îÇ PID: 5678    ‚îÇ
‚îÇ pid = 5678   ‚îÇ         ‚îÇ pid = 0      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Valeurs de retour :

pid = -1 ‚Üí Erreur (pas assez de m√©moire)
pid = 0 ‚Üí On est dans le fils
pid > 0 ‚Üí On est dans le parent (valeur = PID du fils)


8Ô∏è‚É£ Gestion erreur fork
cif (pid == -1)
{
    perror("./shell");
    continue;
}
Si fork() √©choue :
bash#cisfun$ /bin/ls
./shell: Cannot allocate memory
#cisfun$            ‚Üê Continue la boucle

9Ô∏è‚É£ Processus fils (ex√©cution)
cif (pid == 0)
{
    /* Child process */
    if (execve(argv[0], argv, environ) == -1)
    {
        fprintf(stderr, "./shell: No such file or directory\n");
        exit(127);
    }
}
Analyse ligne par ligne
cif (pid == 0)  // On est dans le FILS
cif (execve(argv[0], argv, environ) == -1)
//         ‚îÇ        ‚îÇ      ‚îî‚îÄ Variables environnement
//         ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tableau arguments
//         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Chemin programme
Exemple concret :
c// Commande: /bin/ls -l -a
argv[0] = "/bin/ls"
argv[1] = "-l"
argv[2] = "-a"
argv[3] = NULL

execve("/bin/ls", argv, environ);
Si execve() r√©ussit :

Le processus est remplac√© par /bin/ls
Le code apr√®s execve() n'est JAMAIS ex√©cut√©
Le fils ex√©cute ls et termine

Si execve() √©choue (retourne -1) :
cfprintf(stderr, "./shell: No such file or directory\n");
exit(127);  // Code erreur standard pour "commande introuvable"
Pourquoi exit(127) ?

Convention UNIX : 127 = commande introuvable
Le fils doit terminer (sinon 2 shells en parall√®le!)


üîü Processus parent (attente)
celse
{
    /* Parent process */
    wait(&status);
}
```

**Que fait le parent ?**
1. **Attend** que le fils termine
2. R√©cup√®re le statut de sortie dans `status`
3. Continue la boucle (affiche nouveau prompt)

**Sch√©ma temporel :**
```
Parent                  Fils
  ‚îÇ                      ‚îÇ
  ‚îú‚îÄ fork() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ                      ‚îÇ
  ‚îú‚îÄ wait() ‚îÄ‚îÄ‚Üí BLOQU√â   ‚îú‚îÄ execve("/bin/ls")
  ‚îÇ                      ‚îú‚îÄ Ex√©cute ls
  ‚îÇ                      ‚îú‚îÄ Affiche r√©sultats
  ‚îÇ                      ‚îî‚îÄ Termine (exit)
  ‚îÇ                      
  ‚îú‚îÄ REPREND ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚îÇ
  ‚îî‚îÄ Affiche prompt
Sans wait() :
bash#cisfun$ /bin/sleep 5
#cisfun$              ‚Üê Prompt r√©appara√Æt imm√©diatement !
                      ‚Üê sleep continue en arri√®re-plan
Avec wait() :
bash#cisfun$ /bin/sleep 5
                      ‚Üê Attend 5 secondes...
#cisfun$              ‚Üê Prompt apr√®s la fin de sleep

1Ô∏è‚É£1Ô∏è‚É£ Fin du programme
cfree(line);
return (0);
```

**Pourquoi `free(line)` ?**
- `getline()` fait un `malloc()` automatique
- On doit lib√©rer la m√©moire
- √âvite les fuites m√©moire

---

## üéØ Flux complet d'ex√©cution
```
1. Affiche "#cisfun$ "
2. Attend input: "/bin/ls -l"
3. getline() lit la ligne
4. Enl√®ve '\n' ‚Üí "/bin/ls -l\0"
5. strtok() parse:
   argv[0] = "/bin/ls"
   argv[1] = "-l"
   argv[2] = NULL
6. fork() cr√©e fils
7. FILS:
   execve("/bin/ls", argv, environ)
   ‚Üí Devient ls
   ‚Üí Ex√©cute
   ‚Üí Termine
8. PARENT:
   wait()
   ‚Üí Attend fils
   ‚Üí Reprend
9. Retour √©tape 1 (nouveau prompt)

üìä Tableau r√©capitulatif des fonctions
FonctionR√¥leEntr√©esSortiesisatty()V√©rifie si terminalFD1 ou 0write()√âcrit sur FDFD, buffer, sizeOctets √©critsgetline()Lit ligne compl√®te&line, &len, streamOctets lusstrlen()Longueur cha√ÆnestringNombre charsstrtok()D√©coupe cha√Ænestring, delimToken ou NULLfork()Clone processus-PID (-1/0/>0)execve()Remplace processuspath, argv, env-1 si erreurwait()Attend fils&statusPID filsfprintf()√âcrit format√©stream, format, ...Octets √©critsperror()Affiche erreurprefixvoidexit()Termine processuscode-free()Lib√®re m√©moirepointervoid

üîç Cas d'usage d√©taill√©s
Cas 1 : Commande simple
bashInput: /bin/pwd
cargv[0] = "/bin/pwd"
argv[1] = NULL

execve("/bin/pwd", argv, environ)
// Affiche: /mnt/d/holbertonschool-simple_shell
Cas 2 : Avec arguments
bashInput: /bin/ls -l -a
cargv[0] = "/bin/ls"
argv[1] = "-l"
argv[2] = "-a"
argv[3] = NULL

execve("/bin/ls", argv, environ)
// Affiche: liste d√©taill√©e avec fichiers cach√©s
Cas 3 : Erreur
bashInput: /bin/fausse_cmd arg1
cargv[0] = "/bin/fausse_cmd"
argv[1] = "arg1"
argv[2] = NULL

execve("/bin/fausse_cmd", argv, environ)
// Retourne -1
fprintf(stderr, "./shell: No such file or directory\n")
exit(127)
Cas 4 : Ligne vide
bashInput: [Entr√©e]
cline = "\0"
strlen(line) == 0
continue;  // Ignore, redemande
Cas 5 : EOF
bashInput: ^D (Ctrl+D)
cgetline() retourne -1
break;  // Sort de la boucle
free(line)
return 0;

üêõ Points critiques (bugs courants)
‚ùå Oublier NULL √† la fin
c// MAUVAIS
argv[0] = "/bin/ls";
argv[1] = "-l";
// Pas de NULL !

execve(argv[0], argv, environ);
// Comportement ind√©fini !
c// BON
argv[0] = "/bin/ls";
argv[1] = "-l";
argv[2] = NULL;  // ‚úÖ
‚ùå Oublier free()
c// MAUVAIS
while (1) {
    char *line = NULL;
    getline(&line, &len, stdin);
    // Pas de free !
}
// Fuite m√©moire √† chaque it√©ration
c// BON
char *line = NULL;  // En dehors de la boucle
while (1) {
    getline(&line, &len, stdin);
    // ...
}
free(line);  // Une fois √† la fin
‚ùå Fils ne termine pas
c// MAUVAIS
if (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        // Pas d'exit !
    }
}
// Le fils continue et affiche un prompt !
c// BON
if (pid == 0) {
    if (execve(...) == -1) {
        fprintf(stderr, "Error\n");
        exit(127);  // ‚úÖ
    }
}

üí° Optimisations possibles
1. V√©rifier ligne vide avant strtok
c// Plus efficace
if (strlen(line) == 0)
    continue;

// Avant de parser
i = 0;
token = strtok(line, " \t");
2. Utiliser des constantes
c#define PROMPT "#cisfun$ "
#define PROMPT_LEN 9

write(STDOUT_FILENO, PROMPT, PROMPT_LEN);
3. Fonction s√©par√©e pour parsing
cint parse_line(char *line, char **argv)
{
    int i = 0;
    char *token = strtok(line, " \t");
    
    while (token && i < MAX_ARGS - 1)
    {
        argv[i++] = token;
        token = strtok(NULL, " \t");
    }
    argv[i] = NULL;
    return (i);  // Nombre d'arguments
}

‚úÖ R√©sum√© en une phrase
Ce shell lit une commande avec arguments, la d√©coupe avec strtok(), cr√©e un processus fils avec fork(), ex√©cute la commande dans le fils avec execve(), et le parent attend avec wait() avant d'afficher un nouveau prompt.